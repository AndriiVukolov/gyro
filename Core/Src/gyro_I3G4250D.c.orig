/*
 * gyro_I3G4250D.c
 * @brief Driver for hyroscope motion sensor I3G4250D
 *  Created on: May 28, 2025
 *      Author: Andrii V.
 *
 */

#include "gyro_I3G4250D.h"
<<<<<<< HEAD
#include "stm32f4xx_hal.h"
#include "spi.h"
#include <stdint.h>
=======
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
#include <math.h>
#include <stdint.h>

static uint16_t
LPCutoffCalculation(gyro_t *hGyro) // table 21 (result need to divide by 10)
{
  uint16_t lpcf = 0;
  uint8_t coff = 0 | (hGyro->DataRate << 2) | hGyro->BandWidth;
  uint16_t coffTable[16] = {125, 250, 250, 250,  125, 250, 500, 700,
                            200, 250, 500, 1100, 300, 350, 500, 1100};
  lpcf = coffTable[coff];
  return lpcf;
}

static drate_t OdrCalculation(gyro_t *hGyro) {
  uint16_t odr = (uint16_t)(pow(2, hGyro->DataRate) * 100);
  return (drate_t)odr;
}

static gyroPowMode_t PModeCalculation(gyro_t *hGyro) {
  gyroPowMode_t pm;
  if (hGyro->PDownModeEn == 0)
    pm = DOWN;
  else if ((hGyro->Zen + hGyro->Yen + hGyro->Xen) == 0)
    pm = SLEEP;
  else
    pm = NORMAL;
  return pm;
}

static uint16_t
HPCutoffCalculation(gyro_t *hGyro) // table 26 (need to divide by 100)
{
  uint16_t hpf = 0;
  uint16_t rowOdr[4][10] = {{800, 400, 200, 100, 50, 20, 10, 5, 2, 1},
                            {1500, 800, 400, 200, 100, 50, 20, 10, 5, 2},
                            {3000, 1500, 800, 400, 200, 100, 50, 20, 10, 5},
                            {5600, 3000, 1500, 800, 400, 200, 100, 50, 20, 10}};
  hpf = rowOdr[hGyro->DataRate][hGyro->HPCutOffCode];
  return hpf;
}

<<<<<<< HEAD
static float AngleCalculate(gyro_t* hGyro, int16_t angle)
{
    float res = 0;
    float scale = 0;

    switch (hGyro->FullScale)
    {
		case FS245:
			scale = 8.75;
			break;
		case FS500:
			scale = 17.5;
			break;
		case FS2000:
			scale = 70.0;
			break;
		case FS2000_2:
			scale = 70.0;
			break;
    }
    res = ((float) angle * scale) / 1000;
    return res;
}

gyroError_t gyroReadID(gyro_t* hGyro)
{
	uint8_t idByte = 0;
	uint8_t err = hGyro->funcReadRegs(ADD_WHO_AM_I, 1, &idByte);

	/*WHO_AM_I (0Fh)*/
	if (err != gyroOk) err = gyroCommError;
	else hGyro->Id = idByte;

	return err;
}

gyroError_t gyroReadAll(gyro_t* hGyro, uint8_t *regs)
{
	gyroError_t err = gyroOk;

	err = hGyro->funcReadRegs(ADD_CTRL_REG1, 8, &regs[0]);
	err = hGyro->funcReadRegs(ADD_OUT_X_L, 6, &regs[8]); //cyclic increment of address inside 6 value registers
	err = hGyro->funcReadRegs(ADD_FIFO_CTRL_REG, 11, &regs[14]);

=======
static float AngleCalculate(gyro_t *hGyro, uint16_t angle) {
  float res = 0;
  uint16_t fsval[4] = {245, 500, 2000, 2000};
  res = (float)angle * fsval[hGyro->FullScale];
  return res;
}

static gyroError_t gyroReadAll(gyro_t *hGyro) {
  uint8_t regs[(ADD_INT1_DURATION - ADD_CTRL_REG1 + 2)] = {0};
  uint8_t err = hGyro->funcReadRegs(ADD_WHO_AM_I, 1, regs);
  /*WHO_AM_I (0Fh)*/
  if (err != gyroOk)
    return gyroCommError;
  else
    hGyro->Id = regs[0];

  err = hGyro->funcReadRegs(ADD_CTRL_REG1,
                            (ADD_INT1_DURATION - ADD_CTRL_REG1 + 1), &regs[1]);
  /*CTRL_REG1 (20h)*/
  hGyro->DataRate = (regs[1] & 0xC0) >> 6;
  hGyro->BandWidth = (regs[1] & 0x30) >> 4;
  hGyro->PDownModeEn = (regs[1] & 0x08) >> 3;
  hGyro->Zen = (regs[1] & 0x04) >> 2;
  hGyro->Yen = (regs[1] & 0x02) >> 1;
  hGyro->Xen = (regs[1] & 0x01);
  /*CTRL_REG2 (21h)*/
  hGyro->HPFilterMode = regs[2] & 0x30 >> 4;
  hGyro->HPCutOffCode = regs[2] & 0x0F;
  /*CTRL_REG3 (22h)*/
  hGyro->Int1En = (regs[3] & 0x80) >> 7;
  hGyro->Int1Boot = (regs[3] & 0x40) >> 6;
  hGyro->IntActConfig = (regs[3] & 0x20) >> 5;
  hGyro->IOutType = (regs[3] & 0x10) >> 4;
  hGyro->Int2En = (regs[3] & 0x08) >> 3;
  hGyro->FIFOWtmEn = (regs[3] & 0x04) >> 2;
  hGyro->FIFOOvrnEn = (regs[3] & 0x02) >> 1;
  hGyro->FIFOEmptyEn = (regs[3] & 0x01) >> 0;
  /*CTRL_REG4 (23h)*/
  hGyro->Ble = (regs[4] & 0x40) >> 6;
  hGyro->FullScale = (regs[4] & 0x30) >> 4;
  hGyro->SelfTestEn = (regs[4] & 0x06) >> 1;
  hGyro->SPIModeSel = (regs[4] & 0x01) >> 0;
  /*CTRL_REG5 (24h)*/
  hGyro->Boot = (regs[5] & 0x80) >> 7;
  hGyro->FifoEn = (regs[5] & 0x40) >> 6;
  hGyro->HPFilterEn = (regs[5] & 0x10) >> 4;
  hGyro->Int1SelConf = (regs[5] & 0x0C) >> 2;
  hGyro->OutSelConf = (regs[5] & 0x03) >> 0;
  /*REFERENCE/DATACAPTURE (25h)*/
  hGyro->RefData = regs[6];
  /*OUT_TEMP (26h)*/
  hGyro->OutTemp = regs[7];
  /*STATUS_REG (27h)*/
  hGyro->zyxor = (regs[8] & 0x80) >> 7;
  hGyro->zor = (regs[8] & 0x40) >> 6;
  hGyro->yor = (regs[8] & 0x20) >> 5;
  hGyro->xor = (regs[8] & 0x10) >> 4;
  hGyro->zyxda = (regs[8] & 0x08) >> 3;
  hGyro->zda = (regs[8] & 0x04) >> 2;
  hGyro->yda = (regs[8] & 0x02) >> 1;
  hGyro->xda = (regs[8] & 0x01) >> 0;
  /*OUT_X_L (28h), OUT_X_H (29h)*/
  hGyro->OutX = (regs[9] << 8) | regs[10];
  /*OUT_Y_L (2Ah), OUT_Y_H (2Bh)*/
  hGyro->OutY = (regs[11] << 8) | regs[12];
  /*OUT_Z_L (2Ch), OUT_Z_H (2Dh)*/
  hGyro->OutZ = (regs[13] << 8) | regs[14];
  /*FIFO_CTRL_REG (2Eh)*/
  hGyro->FifoModeSel = (regs[15] & 0xE0) >> 5;
  hGyro->FifoThreshold = regs[15] & 0x1F;
  /*FIFO_SRC_REG (2Fh)*/
  hGyro->FifoWtmStatus = (regs[16] & 0x80) >> 7;
  hGyro->FifoOvrnStatus = (regs[16] & 0x40) >> 6;
  hGyro->FifoEmpty = (regs[16] & 0x20) >> 5;
  hGyro->FifoStored = (regs[16] & 0x1F);
  /*INT1_CFG (30h)*/
  hGyro->Andor = (regs[17] & 0x80) >> 7;
  hGyro->Lir = (regs[17] & 0x40) >> 6;
  hGyro->ZHIE = (regs[17] & 0x20) >> 5;
  hGyro->ZLIE = (regs[17] & 0x10) >> 4;
  hGyro->YHIE = (regs[17] & 0x08) >> 3;
  hGyro->YLIE = (regs[17] & 0x04) >> 2;
  hGyro->XHIE = (regs[17] & 0x02) >> 1;
  hGyro->XLIE = (regs[17] & 0x01) >> 0;
  /*INT1_SRC (31h)*/
  //(regs[18] & 0x80) >> 7 = 0
  hGyro->InterruptFlags->IntFlag = (regs[18] & 0x40) >> 6;
  hGyro->InterruptFlags->ZhighFlag = (regs[18] & 0x20) >> 5;
  hGyro->InterruptFlags->ZLowFlag = (regs[18] & 0x10) >> 4;
  hGyro->InterruptFlags->YhighFlag = (regs[18] & 0x08) >> 3;
  hGyro->InterruptFlags->YlowFlag = (regs[18] & 0x04) >> 2;
  hGyro->InterruptFlags->XhighFlag = (regs[18] & 0x02) >> 1;
  hGyro->InterruptFlags->XlowFlag = (regs[18] & 0x01) >> 0;
  /*INT1_THS_XH (32h)*/
  hGyro->Int1XHighTr = regs[19];
  /*INT1_THS_XL (33h)*/
  hGyro->Int1XLowTr = regs[20];
  /*INT1_THS_YH (34h)*/
  hGyro->Int1YHighTr = regs[21];
  /*INT1_THS_YL (35h)*/
  hGyro->Int1YLowTr = regs[22];
  /*INT1_THS_ZH (36h)*/
  hGyro->Int1ZHighTr = regs[23];
  /*INT1_THS_ZL (37h)*/
  hGyro->Int1ZLowTr = regs[24];
  /*INT1_DURATION (38h)*/
  hGyro->Int1Wait = (regs[25] & 0x80) >> 7;
  hGyro->Int1Duration = (regs[25] & 0x7F);
  // Output data rate calculation
  hGyro->Odr = OdrCalculation(hGyro);
  // LP Cutoff defining
  hGyro->LPCutOff = LPCutoffCalculation(hGyro);
  // HP Cutoff defining
  hGyro->HPCutOff = HPCutoffCalculation(hGyro);
  // Power mode defining
  hGyro->PowerMode = PModeCalculation(hGyro);
  return err;
}

gyroError_t gyroInit(gyro_t *hGyro) {
  gyroError_t err;
  if (gyroReadAll(hGyro) != gyroOk)
    err = gyroInitError;
  else
    err = gyroOk;
  return err;
}

gyroError_t gyroDeinit(gyro_t *hGyro) {};

gyroError_t gyroPowerDown(gyro_t *hGyro) // CTRL_REG1 (20h)
{
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

  hGyro->PowerMode = DOWN;
  err = hGyro->funcReadRegs(ADD_CTRL_REG1, 1, &dataByte);
  if (err != gyroOk)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
    return err;
  dataByte &= 0xF7;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG1, 1, &dataByte);
  return err;
}
gyroError_t gyroSleep(gyro_t *hGyro) // CTRL_REG1 (20h)
{
<<<<<<< HEAD
    gyroError_t err;

    err = gyroSetOutMode(hGyro);
    err = gyroSetIntMode(hGyro);
    err = gyroSetFullScale(hGyro);
    err = gyroSetFifoMode(hGyro);
    err = gyroTurnOn(hGyro);
    err = gyroSetHPFilter(hGyro);

=======
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

  hGyro->PowerMode = SLEEP;
  err = hGyro->funcReadRegs(ADD_CTRL_REG1, 1, &dataByte);
  if (err != gyroOk)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
    return err;
  dataByte &= 0xF8;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG1, 1, &dataByte);
  return err;
}
gyroError_t gyroTurnOn(gyro_t *hGyro) // CTRL_REG1 (20h)
{
<<<<<<< HEAD
	return gyroOk;
};

gyroError_t gyroTurnOff(gyro_t* hGyro)//CTRL_REG1 (20h)
{
    uint8_t dataByte = 0;
    gyroError_t err = gyroOk;

    hGyro->PowerMode = DOWN;
    err = hGyro->funcReadRegs(ADD_CTRL_REG1,1,&dataByte);
    if (err != gyroOk) return err;
    dataByte &= 0xF0;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG1, 1, &dataByte);
=======
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

  hGyro->PowerMode = NORMAL;
  err = hGyro->funcReadRegs(ADD_CTRL_REG1, 1, &dataByte);
  if (err != gyroOk)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
    return err;
  if ((dataByte & 0x07) > 0)
    dataByte |= 0x08;
  else
    dataByte |= 0x0F;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG1, 1, &dataByte);
  return err;
}
gyroError_t gyroReadVal(gyro_t *hGyro,
                        float *gVal) // OUT_X_L (28h) - OUT_Z_H (2Dh)
{
  uint8_t dataByte = 0;
  uint8_t buff[6] = {0};
  uint16_t val = 0;
  uint8_t i = 0;
  gyroError_t err = gyroOk;

<<<<<<< HEAD
    hGyro->PowerMode = SLEEP;
    err = hGyro->funcReadRegs(ADD_CTRL_REG1,1,&dataByte);
    if (err != gyroOk) return err;
    dataByte &= 0xF0;
    dataByte |= 0x08;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG1, 1, &dataByte);
    return err;
}
gyroError_t gyroTurnOn(gyro_t* hGyro)//CTRL_REG1 (20h)
{
    uint8_t dataByte = 0;
    gyroError_t err = gyroOk;

    hGyro->PowerMode = NORMAL;
    dataByte = (hGyro->DataRate << 6) | (hGyro->BandWidth << 4) | (hGyro->PDownModeEn << 3) | (hGyro->Zen << 2) | (hGyro->Yen << 1) | hGyro->Xen;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG1, 1, &dataByte);
    return err;
}

gyroError_t gyroReadVal(gyro_t* hGyro, float* gVal)//OUT_X_L (28h) - OUT_Z_H (2Dh)
{
    uint8_t buff[6] = {0};
    int16_t val[3] = {0};
    uint8_t i = 0;
    gyroError_t err = gyroOk;
    uint8_t n = 0;

    err = gyroReadFifoStatus(hGyro);

    if (hGyro->FifoEn == 1) n = hGyro->FifoStored;
    else n = 1;

	if ((n == 31) && (hGyro->FifoOvrnStatus == 1)) n = 32;

    while ((n--) > 0)
	{
    	err = hGyro->funcReadRegs(ADD_OUT_X_L, 6, buff);
	}
    // check in the control register 4 the data alignment (Big Endian or Little Endian)
    //(0: data LSB @ lower address; 1: data MSB @ lower address)
    if (hGyro->Ble == 0)
    {
        for (i = 0; i < 3; i++)
        {
            val[i] = (int16_t)(((uint16_t)buff[2 * i + 1] << 8) + buff[2 * i]);
            gVal[i] = AngleCalculate(hGyro, val[i]);
        }
    }
    else
    {
        for (i = 0; i < 3; i++)
        {
            val[i] = (int16_t)(((uint16_t)buff[2 * i] << 8) + buff[2 * i + 1]);
            gVal[i] = AngleCalculate(hGyro, val[i]);
        }
    }
    hGyro->OutX = val[0];
    hGyro->OutY = val[1];
    hGyro->OutZ = val[2];

    return err;
=======
  err = hGyro->funcReadRegs(ADD_CTRL_REG4, 1, &dataByte);
  if (err != gyroOk)
    return err;
  hGyro->FullScale = (0x30 >> 4);
  hGyro->Ble = (0x40 >> 6);
  err = hGyro->funcReadRegs(ADD_OUT_X_L, 6, buff);
  // check in the control register 4 the data alignment (Big Endian or Little
  // Endian)
  //(0: data LSB @ lower address; 1: data MSB @ lower address)
  if (hGyro->Ble == 0) {
    for (i = 0; i < 3; i++) {
      val = (int16_t)(((uint16_t)buff[2 * i + 1] << 8) + buff[2 * i]);
      gVal[i] = AngleCalculate(hGyro, val);
    }
  } else {
    for (i = 0; i < 3; i++) {
      val = (int16_t)(((uint16_t)buff[2 * i] << 8) + buff[2 * i + 1]);
      gVal[i] = AngleCalculate(hGyro, val);
    }
  }
  return gyroOk;
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
}

gyroError_t gyroReadStatus(gyro_t *hGyro) // STATUS_REG (27h)
{

  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

  err = hGyro->funcReadRegs(ADD_STATUS_REG, 1, &dataByte);
  if (err != gyroOk)
    return err;
  hGyro->zyxor = (dataByte & 0x80) >> 7;
  hGyro->zor = (dataByte & 0x40) >> 6;
  hGyro->yor = (dataByte & 0x20) >> 5;
  hGyro->xor = (dataByte & 0x10) >> 4;
  hGyro->zyxda = (dataByte & 0x08) >> 3;
  hGyro->zda = (dataByte & 0x04) >> 2;
  hGyro->yda = (dataByte & 0x02) >> 1;
  hGyro->xda = (dataByte & 0x01) >> 0;
  return err;
}

gyroError_t gyroReadFifoStatus(gyro_t *hGyro) // FIFO_SRC_REG (2Fh)
{
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

<<<<<<< HEAD
    err = hGyro->funcReadRegs(ADD_FIFO_SRC_REG, 1, &dataByte);
    if (err != gyroOk) return err;
    hGyro->FifoWtmStatus = (dataByte & 0x80) >> 7;
    hGyro->FifoOvrnStatus = (dataByte & 0x40) >> 6;
    hGyro->FifoEmpty = (dataByte & 0x20) >> 5;
    hGyro->FifoStored = (dataByte & 0x1F);
    err = hGyro->funcReadRegs(ADD_CTRL_REG1, 1, &dataByte);
    if (err != gyroOk) return err;
    hGyro->Boot = (dataByte & 0x80) >> 7;
	hGyro->FifoEn = (dataByte & 0x40) >> 6;
	hGyro->HPFilterEn = (dataByte & 0x10) >> 4;
	hGyro->Int1SelConf = (dataByte & 0x0C) >> 2;
	hGyro->OutSelConf = (dataByte & 0x03) >> 0;

=======
  err = hGyro->funcReadRegs(ADD_FIFO_SRC_REG, 1, &dataByte);
  if (err != gyroOk)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
    return err;
  hGyro->FifoWtmStatus = (dataByte & 0x80) >> 7;
  hGyro->FifoOvrnStatus = (dataByte & 0x40) >> 6;
  hGyro->FifoEmpty = (dataByte & 0x20) >> 5;
  hGyro->FifoStored = (dataByte & 0x1F);
  return err;
}

gyroError_t gyroReadIntStatus(gyro_t *hGyro) // INT1_SRC (31h)
{
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

  err = hGyro->funcReadRegs(ADD_INT1_SRC, 1, &dataByte);
  if (err != gyroOk)
    return err;
  hGyro->InterruptFlags->IntFlag = (dataByte & 0x40) >> 6;
  hGyro->InterruptFlags->ZhighFlag = (dataByte & 0x20) >> 5;
  hGyro->InterruptFlags->ZLowFlag = (dataByte & 0x10) >> 4;
  hGyro->InterruptFlags->YhighFlag = (dataByte & 0x08) >> 3;
  hGyro->InterruptFlags->YlowFlag = (dataByte & 0x04) >> 2;
  hGyro->InterruptFlags->XhighFlag = (dataByte & 0x02) >> 1;
  hGyro->InterruptFlags->XlowFlag = (dataByte & 0x01) >> 0;
  return err;
}

gyroError_t gyroSetOutDataRate(gyro_t *hGyro,
                               drate_t dataRate) // CTRL_REG1 (20h)
{
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

  hGyro->Odr = dataRate;
  hGyro->DataRate = (uint8_t)sqrt((double)dataRate / 100);
  err = hGyro->funcReadRegs(ADD_CTRL_REG1, 1, &dataByte);
  if (err != gyroOk)
    return err;
  dataByte = (dataByte & 0x3F) | (hGyro->DataRate << 6);
  err = hGyro->funcWriteRegs(ADD_CTRL_REG1, 1, &dataByte);
  return err;
}

<<<<<<< HEAD
gyroError_t gyroSetHPFilter(gyro_t* hGyro)//CTRL_REG2 (21h)
=======
gyroError_t gyroSetHPFilter(gyro_t *hGyro, gyroHPMode_t mode,
                            gyroHpcf_t freq) // CTRL_REG2 (21h)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
{
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

<<<<<<< HEAD
    dataByte = 0 | (hGyro->HPFilterMode << 4) | hGyro->HPCutOffCode;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG2, 1, &dataByte);
=======
  err = hGyro->funcReadRegs(ADD_CTRL_REG2, 1, &dataByte);
  if (err != gyroOk)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
    return err;
  hGyro->HPFilterMode = (uint8_t)mode;
  hGyro->HPCutOffCode = (uint8_t)freq;
  dataByte = 0 | (hGyro->HPFilterMode << 4) | hGyro->HPCutOffCode;
  hGyro->HPCutOff = HPCutoffCalculation(hGyro);
  err = hGyro->funcWriteRegs(ADD_CTRL_REG2, 1, &dataByte);
  return err;
}

<<<<<<< HEAD
gyroError_t gyroSetFifoMode(gyro_t* hGyro)//FIFO_CTRL_REG (2Eh)
=======
gyroError_t gyroSetFifoMode(gyro_t *hGyro, gyroMode_t mode,
                            uint16_t wtm) // FIFO_CTRL_REG (2Eh)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
{
  uint8_t dataByte = 0;
  gyroError_t err = gyroOk;

<<<<<<< HEAD
    dataByte &= (hGyro->FifoModeSel << 5) | hGyro->FifoThreshold;
    err = hGyro->funcWriteRegs(ADD_FIFO_CTRL_REG, 1, &dataByte);
    return err;
}

gyroError_t gyroSetIntMode(gyro_t* hGyro)// CTRL_REG3 (22h), INT1_CFG (30h), INT1_DURATION (38h)
{
    uint8_t dataByte = 0;
    gyroError_t err = gyroOk;

    //int sources
    dataByte = 0 | (hGyro->Andor << 7) | (hGyro->Lir << 6) | (hGyro->ZHIE << 5) | (hGyro->ZLIE << 4)\
                 | (hGyro->YHIE << 3) | (hGyro->YLIE << 2) | (hGyro->XHIE << 1) | hGyro->XLIE;
    err = hGyro->funcWriteRegs(ADD_INT1_CFG, 1, &dataByte);
    if (err != gyroOk) return err;
    //FIFO int sources
    dataByte = 0 | (hGyro->Int1En << 7) | (hGyro->Int1Boot << 6) | (hGyro->IntActConfig << 5) | (hGyro->IOutType << 4) \
                 | (hGyro->Int2En << 3) | (hGyro->FIFOWtmEn << 2) | (hGyro->FIFOOvrnEn << 1) | hGyro->FIFOEmptyEn;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG3, 1, &dataByte);
    if (err != gyroOk) return err;
    //int duration
    dataByte = 0 | (hGyro->Int1Wait << 7) | hGyro->Int1Duration;
    err = hGyro->funcWriteRegs(ADD_INT1_DURATION, 1, &dataByte);
    //int thresholds
    err = hGyro->funcWriteRegs(ADD_INT1_THS_XH, 1, &hGyro->Int1XHighTr);
    err = hGyro->funcWriteRegs(ADD_INT1_THS_XL, 1, &hGyro->Int1XLowTr);
    err = hGyro->funcWriteRegs(ADD_INT1_THS_YH, 1, &hGyro->Int1YHighTr);
    err = hGyro->funcWriteRegs(ADD_INT1_THS_YL, 1, &hGyro->Int1YLowTr);
    err = hGyro->funcWriteRegs(ADD_INT1_THS_ZH, 1, &hGyro->Int1ZHighTr);
    err = hGyro->funcWriteRegs(ADD_INT1_THS_ZL, 1, &hGyro->Int1ZLowTr);
=======
  hGyro->FifoModeSel = mode;
  hGyro->FifoThreshold = wtm;
  dataByte &= (hGyro->FifoModeSel << 5) | hGyro->FifoThreshold;
  err = hGyro->funcWriteRegs(ADD_FIFO_CTRL_REG, 1, &dataByte);
  return err;
}

gyroError_t gyroSetIntMode(
    gyro_t *hGyro) // CTRL_REG3 (22h), INT1_CFG (30h), INT1_DURATION (38h)
{
  int8_t dataByte = 0;
  gyroError_t err = gyroOk;

  // int sources
  dataByte = 0 | (hGyro->Andor << 7) | (hGyro->Lir << 6) | (hGyro->ZHIE << 5) |
             (hGyro->ZLIE << 4) | (hGyro->YHIE << 3) | (hGyro->YLIE << 2) |
             (hGyro->XHIE << 1) | hGyro->XLIE;
  err = hGyro->funcWriteRegs(ADD_INT1_CFG, 1, &dataByte);
  if (err != gyroOk)
    return err;
  // FIFO int sources
  dataByte = 0 | (hGyro->Int1En << 7) | (hGyro->Int1Boot << 6) |
             (hGyro->IntActConfig << 5) | (hGyro->IOutType << 4) |
             (hGyro->Int2En << 3) | (hGyro->FIFOWtmEn << 2) |
             (hGyro->FIFOOvrnEn << 1) | hGyro->FIFOEmptyEn;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG3, 1, &dataByte);
  if (err != gyroOk)
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
    return err;
  // int duration
  dataByte = 0 | (hGyro->Int1Wait << 7) | hGyro->Int1Duration;
  err = hGyro->funcWriteRegs(ADD_INT1_DURATION, 1, &dataByte);
  return err;
}

gyroError_t gyroSetOutMode(gyro_t *hGyro) // CTRL_REG5 (24h)
{
<<<<<<< HEAD
    uint8_t dataByte = 0;
    gyroError_t err = gyroOk;
=======
  int8_t dataByte = 0;
  gyroError_t err = gyroOk;
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986

  dataByte = 0 | (hGyro->Boot << 7) | (hGyro->FifoEn << 6) |
             (hGyro->HPFilterEn << 4) | (hGyro->Int1SelConf << 2) |
             hGyro->OutSelConf;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG5, 1, &dataByte);
  return err;
}

gyroError_t gyroSetBle(gyro_t *hGyro, uint8_t ble) // CTRL_REG4 (23h)
{
  int8_t dataByte = 0;
  gyroError_t err = gyroOk;
  err = hGyro->funcReadRegs(ADD_CTRL_REG4, 1, &dataByte);
  if (err != gyroOk)
    return err;
  hGyro->Ble = ble;
  ble = (ble << 6) | 0xBF;
  dataByte &= ble;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG4, 1, &dataByte);
  return err;
}

gyroError_t gyroSetFullScale(gyro_t *hGyro, fscale_t type) // CTRL_REG4 (23h)
{
  int8_t dataByte = 0;
  gyroError_t err = gyroOk;

  err = hGyro->funcReadRegs(ADD_CTRL_REG4, 1, &dataByte);
  if (err != gyroOk)
    return err;
  hGyro->FullScale = type;
  type = (type << 6) | 0xCF;
  dataByte &= type;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG4, 1, &dataByte);
  return err;
}

gyroError_t gyroSelfTest(gyro_t *hGyro, uint8_t conf) // CTRL_REG4 (23h)
{
  int8_t dataByte = 0;
  gyroError_t err = gyroOk;

  err = hGyro->funcReadRegs(ADD_CTRL_REG4, 1, &dataByte);
  if (err != gyroOk)
    return err;
  dataByte |= conf << 1;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG4, 1, &dataByte);
  if (err != gyroOk)
    return err;
  gyroReadAll(hGyro);
  if (hGyro->SelfTestEn != 0) {
    dataByte &= 0x79; // reset ST1-ST0 bits
    err = hGyro->funcWriteRegs(ADD_CTRL_REG5, 1, &dataByte);
  }
  return err;
}

<<<<<<< HEAD
gyroError_t gyroReadReg5(gyro_t* hGyro)
{
	uint8_t dataByte = 0;
	gyroError_t err = gyroOk;

	err = hGyro->funcReadRegs(ADD_CTRL_REG5, 1, &dataByte);
	hGyro->Boot = (dataByte & 0x80) >> 7;
	hGyro->FifoEn = (dataByte & 0x40) >> 6;
	hGyro->HPFilterEn = (dataByte & 0x10) >> 4;
	hGyro->Int1SelConf = (dataByte & 0x0C) >> 2;
	hGyro->OutSelConf = (dataByte & 0x03) >> 0;

	return err;
}


gyroError_t gyroReadReference(gyro_t* hGyro)
{
	uint8_t dataByte = 0;
	gyroError_t err = gyroOk;

	err = hGyro->funcReadRegs(ADD_REFERENCE, 1, &dataByte);

	return err;
}

gyroError_t gyroSetBle(gyro_t* hGyro, uint8_t ble)//CTRL_REG4 (23h)
{
    uint8_t dataByte = 0;
    gyroError_t err = gyroOk;
    err = hGyro->funcReadRegs(ADD_CTRL_REG4, 1, &dataByte);
    if (err != gyroOk) return err;
    hGyro->Ble = ble;
    ble = (ble << 6) | 0xBF;
    dataByte &= ble;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG4, 1, &dataByte);
    return err;
}

gyroError_t gyroSetFullScale(gyro_t* hGyro)//CTRL_REG4 (23h)
{
    uint8_t dataByte = 0;
    gyroError_t err = gyroOk;

    dataByte = 0 | (hGyro->Ble << 6) | (hGyro->FullScale << 4) | (hGyro->SelfTestEn << 1) | hGyro->SPIModeSel;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG4, 1, &dataByte);
    return err;
}

gyroError_t gyroSelfTest(gyro_t* hGyro, uint8_t conf)//CTRL_REG4 (23h)
{
    uint8_t dataByte = 0;
    uint8_t buf[32];
    gyroError_t err = gyroOk;

    err = hGyro->funcReadRegs(ADD_CTRL_REG4,1,&dataByte);
    if (err != gyroOk) return err;
    dataByte |= conf << 1;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG4, 1, &dataByte);
    if (err != gyroOk) return err;
    gyroReadAll(hGyro, buf);
    if (hGyro->SelfTestEn != 0)
    {
        dataByte &= 0x79;//reset ST1-ST0 bits
        err = hGyro->funcWriteRegs(ADD_CTRL_REG5, 1, &dataByte);
    }
    return err;
}

gyroError_t gyroReboot(gyro_t* hGyro)
{
    uint8_t dataByte = 0;
    uint8_t buf[32];
    gyroError_t err = gyroOk;

    err = hGyro->funcReadRegs(ADD_CTRL_REG5, 1, &dataByte);
    if (err != gyroOk) return err;
    dataByte |= 0x80;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG5, 1, &dataByte);
    if (err != gyroOk) return err;
    gyroReadAll(hGyro, buf);
    if (hGyro->Boot)
    {
        hGyro->Boot = 0;
        dataByte = (hGyro->Boot << 7) | (hGyro->FifoEn << 6) | (hGyro->HPFilterEn << 4) | (hGyro->Int1SelConf << 2) | hGyro->OutSelConf;
        err = hGyro->funcWriteRegs(ADD_CTRL_REG5, 1, &dataByte);
    }
    return err;
}














=======
gyroError_t gyroReboot(gyro_t *hGyro) {
  int8_t dataByte = 0;
  gyroError_t err = gyroOk;

  err = hGyro->funcReadRegs(ADD_CTRL_REG5, 1, &dataByte);
  if (err != gyroOk)
    return err;
  dataByte |= 0x80;
  err = hGyro->funcWriteRegs(ADD_CTRL_REG5, 1, &dataByte);
  if (err != gyroOk)
    return err;
  gyroReadAll(hGyro);
  if (hGyro->Boot) {
    hGyro->Boot = 0;
    dataByte = (hGyro->Boot << 7) | (hGyro->FifoEn << 6) |
               (hGyro->HPFilterEn << 4) | (hGyro->Int1SelConf << 2) |
               hGyro->OutSelConf;
    err = hGyro->funcWriteRegs(ADD_CTRL_REG5, 1, &dataByte);
  }
  return err;
}
>>>>>>> fcbc8372c39e5d1f759bd73d45b6538693885986
